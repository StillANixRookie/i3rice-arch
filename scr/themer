#!/usr/bin/env bash

# OA: Gavin Vales
# CREATED: Mon 29 Jul 19:21:39 BST 2019

TDR=$HOME/.config/themer DEF=${TDR}/.defaults
create_def () {
cat > $DEF << 'EOB'
! vim:ft=perl
! default theme, gruvbox light, basically
name      default_theme
guifont   Noto Sans
font      monospace
size      11
rxvtsize  12
bg0       #fbf1c7
fg0       #282828
acc       #689d6a
red       #cc241d
grn       #98971a
ylw       #d79921
gnt       #b16286
blu       #458588
cyn       #689d6a
orange    #d65d0e
EOB
exit
}
awklib () {
cat << 'EOB'
function hextorgb(HEX,NME){
	HEXR=substr(HEX,2,length(HEX)-5);
	HEXG=substr(HEX,4,length(HEX)-5);
	HEXB=substr(HEX,6,length(HEX)-5);
	print NME "RGB    " strtonum( "0x" HEXR ) ", " strtonum( "0x" HEXG ) ", " strtonum( "0x" HEXB );
	}

function mixer(NME,ONE,TWO,RT1,RT2){
	ONER=substr(ONE,2,length(ONE)-5);
	ONEG=substr(ONE,4,length(ONE)-5);
	ONEB=substr(ONE,6,length(ONE)-5);
	TWOR=substr(TWO,2,length(TWO)-5);
	TWOG=substr(TWO,4,length(TWO)-5);
	TWOB=substr(TWO,6,length(TWO)-5);
	ONRR=strtonum("0x" ONER); ONRG=strtonum("0x" ONEG); ONRB=strtonum("0x" ONEB);
	TWRR=strtonum("0x" TWOR); TWRG=strtonum("0x" TWOG); TWRB=strtonum("0x" TWOB);
	CL3R=int(((ONRR * RT1) / 100) + ((TWRR * RT2) / 100));
	CL3G=int(((ONRG * RT1) / 100) + ((TWRG * RT2) / 100));
	CL3B=int(((ONRB * RT1) / 100) + ((TWRB * RT2) / 100));
	CL3RX=sprintf("%x",CL3R); CL3GX=sprintf("%x",CL3G); CL3BX=sprintf("%x",CL3B);
	if (length(CL3RX)==1) {CL3RX="0"CL3RX}
	if (length(CL3GX)==1) {CL3GX="0"CL3GX}
	if (length(CL3BX)==1) {CL3BX="0"CL3BX}
	print NME " #" CL3RX CL3GX CL3BX;
	}

function colmixparse(NME,ONE,TWO,RT1,RT2){
	ONER=substr(ONE,2,length(ONE)-5);
	ONEG=substr(ONE,4,length(ONE)-5);
	ONEB=substr(ONE,6,length(ONE)-5);
	TWOR=substr(TWO,2,length(TWO)-5);
	TWOG=substr(TWO,4,length(TWO)-5);
	TWOB=substr(TWO,6,length(TWO)-5);
	ONRR=strtonum("0x" ONER); ONRG=strtonum("0x" ONEG); ONRB=strtonum("0x" ONEB);
	TWRR=strtonum("0x" TWOR); TWRG=strtonum("0x" TWOG); TWRB=strtonum("0x" TWOB);
	CL3R=int((ONRR * RT1 + TWRR * RT2) / 100);
	CL3G=int((ONRG * RT1 + TWRG * RT2) / 100);
	CL3B=int((ONRB * RT1 + TWRB * RT2) / 100);
	CL3RX=sprintf("%x",CL3R); CL3GX=sprintf("%x",CL3G); CL3BX=sprintf("%x",CL3B);
	if (length(CL3RX)==1) {CL3RX="0"CL3RX}
	if (length(CL3GX)==1) {CL3GX="0"CL3GX}
	if (length(CL3BX)==1) {CL3BX="0"CL3BX}
	print ";s/colmix " mix "/#" CL3RX CL3GX CL3BX "/g";
	}

EOB
exit
}
[[ -d $TDR ]] || mkdir $TDR
[[ -f $DEF ]] || create_def
vrt=light
CUR=${TDR}/.current ALL=${TDR}/.allvars ALR=${TDR}/.allvarsrofi RGX=${TDR}/.regex
DIRS=${TDR}/.dirs LST=${TDR}/.themelist
TIME=$(date | awk '{print $4}')
TIME=${TIME%%:*}

help () {
cat << 'EOB'
# themer
- A script to change theme of configs using a theme file.
Inspired by budlabs' mondo-generator from the AUR.

## Usage

```
themer [--change|-c|--new|-n] <name> [--dark|-D|--auto-dark|-t]
themer [--getvar|-v] <variable>
themer [--list|-l] themes|vars|vars-rofi
themer [--apply-single|-a] <directory>
themer [--apply-all|-A|--updatelist|-u]
themer --help|-h
themer
```

## Options

+ Run with no options to create defaults in:
	+ $THEMER_DIR = $HOME/.config/themer.

+ `--change|-c <theme>`
	+ Change current theme to `<theme>`.
	If `<theme>` is empty, a rofi list of themes will be displayed.
	Requires my i3menu rofi wrapper.

+ `--apply-single|-a <directory>`
	+ Apply current theme to `<directory>`.

+ `--apply-all|-A`
	+ Apply current theme to directories listed in $THEMER_DIR/.dirs.

+ `--getvar|-v <variable>`
	+ Get `<variable>` from current theme.

+ `--new|-n <name>`
	+ Create theme `<name>`.

+ `--list|-l themes|vars|vars-rofi`
	+ themes = list themes in $THEMER_DIR.
	+ vars = list vars of current theme.
	+ vars-rofi = rofi list of variables in current theme.

+ `--updatelist|-u`
	+ Update rofi theme list for -c.

+ `--dark|-D`
	+ Dark mode (switches fgo and bg0).

+ `--auto-dark|-t <am_time>:<pm_time>`
	+ Dark/Light mode based on time of day.
	+ `<am_time>` hr to apply 'light' mode.
	+ `<pm_time>` hr to apply 'dark' mode.
	+ Uses 24-hr time format

+ `--help|-h`
	+ Display this help.


## Making Themes

Using themer -n will prompt to create the required
fg0 [foreground], bg0 [background] and acc [accent]
colour variables.

The rest of the variables will be taken from the
$THEMER_DIR/.default theme, created automatically,
and the .default theme can be changed as you wish.

You can also reference variables using a '$' in front
of the variable name in the theme file and you can
also mix colours. XX are required mix ratios,
and HEX are actual colours, or variables:

```
<color>    colmix XX:HEX XX:HEX
```

## Generating Themes

```
themer --change <theme>
```

to change the current theme and generate all variables,
including fg0, bg0, and acc variations

## Making Theme Template

To make a theme template, cd into the desired config
`<directory>`, duplicate the file(s) you wish to
template with the "template_" prefix, and replace
all colors or other things with the variables
in the current theme.

The variables are to be referenced with: `%%<variable>%%`.
Add RGB after colour name to get its RGB value
in "R, G, B" form eg. `%%bg0RGB%%`. Use `@@color@@` instead
of `%%color%%` to get hex color without '#'. Useful for
`#AARRGGBB` colors.

Create _pre-apply and _post-apply bash scripts in
the `<directory>` to eg. reload i3 etc. before/after
applying a theme.

```
themer -a <directory>
```

to apply the theme to each template in `<directory>`.

```
themer --apply-all
```

to apply theme to all directories listed in
$THEMER_DIR/.dirs

EOB
#├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤▒▒
#│ %%acc%% accent             │▒▒
exit
}

variations () {
	bg0=$(sed '/^bg0 /!d;s/[^ ]* *//' $ALL)
	fg0=$(sed '/^fg0 /!d;s/[^ ]* *//' $ALL)
	acc=$(sed '/^acc /!d;s/[^ ]* *//' $ALL)
	hexrgbraw $bg0 bg0
	hexrgbraw $fg0 fg0
	[[ $bg0R -le 127 ]] || [[ $bg0G -le 127 ]] || [[ $bg0B -le 127 ]] && vrt=dark

	awk -i <(awklib) -v bg0="$bg0" -v fg0="$fg0" '
		/#/ && !/^fg0|^bg0|^acc/ {
			key=$1;val=$2;
			mixer("dark"key,val,fg0,50,50)
			mixer("light"key,val,bg0,50,50)
		}' $ALL >> $ALL

	awk -i <(awklib) -v VRT="$vrt" -v INC="20" \
		-v bg0R="$bg0R" -v bg0G="$bg0G" -v bg0B="$bg0B" \
		-v fg0R="$fg0R" -v fg0G="$fg0G" -v fg0B="$fg0B" \
		-v bg0="$bg0" -v fg0="$fg0" -v acc="$acc" '
		BEGIN {
			if (VRT=="light") {
				fg1R=fg0R + INC; fg1G=fg0G + INC; fg1B=fg0B + INC;
				fg2R=fg1R + INC; fg2G=fg1G + INC; fg2B=fg1B + INC;
				fg3R=fg2R + INC; fg3G=fg2G + INC; fg3B=fg2B + INC;
				bg1R=bg0R - INC; bg1G=bg0G - INC; bg1B=bg0B - INC;
				bg2R=bg1R - INC; bg2G=bg1G - INC; bg2B=bg1B - INC;
				bg3R=bg2R - INC; bg3G=bg2G - INC; bg3B=bg2B - INC;
			} else {
				fg1R=fg0R - INC; fg1G=fg0G - INC; fg1B=fg0B - INC;
				fg2R=fg1R - INC; fg2G=fg1G - INC; fg2B=fg1B - INC;
				fg3R=fg2R - INC; fg3G=fg2G - INC; fg3B=fg2B - INC;
				bg1R=bg0R + INC; bg1G=bg0G + INC; bg1B=bg0B + INC;
				bg2R=bg1R + INC; bg2G=bg1G + INC; bg2B=bg1B + INC;
				bg3R=bg2R + INC; bg3G=bg2G + INC; bg3B=bg2B + INC;
			}

			sub(/-/,"",fg1R);sub(/-/,"",fg1G);sub(/-/,"",fg1B);
			sub(/-/,"",fg2R);sub(/-/,"",fg2G);sub(/-/,"",fg2B);
			sub(/-/,"",fg3R);sub(/-/,"",fg3G);sub(/-/,"",fg3B);
			sub(/-/,"",bg1R);sub(/-/,"",bg1G);sub(/-/,"",bg1B);
			sub(/-/,"",bg2R);sub(/-/,"",bg2G);sub(/-/,"",bg2B);
			sub(/-/,"",bg3R);sub(/-/,"",bg3G);sub(/-/,"",bg3B);
			if (fg3R>255) {fg3R=255}; if (fg3G>255) {fg3G=255}; if (fg3B>255) {fg3B=255}
			if (fg2R>255) {fg2R=255}; if (fg2G>255) {fg2G=255}; if (fg2B>255) {fg2B=255}
			if (fg1R>255) {fg1R=255}; if (fg1G>255) {fg1G=255}; if (fg1B>255) {fg1B=255}
			if (bg1R>255) {bg1R=255}; if (bg1G>255) {bg1G=255}; if (bg1B>255) {bg1B=255}
			if (bg2R>255) {bg2R=255}; if (bg2G>255) {bg2G=255}; if (bg2B>255) {bg2B=255}
			if (bg3R>255) {bg3R=255}; if (bg3G>255) {bg3G=255}; if (bg3B>255) {bg3B=255}

			fg1RX=sprintf("%x",fg1R); fg1GX=sprintf("%x",fg1G); fg1BX=sprintf("%x",fg1B);
			fg2RX=sprintf("%x",fg2R); fg2GX=sprintf("%x",fg2G); fg2BX=sprintf("%x",fg2B);
			fg3RX=sprintf("%x",fg3R); fg3GX=sprintf("%x",fg3G); fg3BX=sprintf("%x",fg3B);
			bg3RX=sprintf("%x",bg3R); bg3GX=sprintf("%x",bg3G); bg3BX=sprintf("%x",bg3B);
			bg2RX=sprintf("%x",bg2R); bg2GX=sprintf("%x",bg2G); bg2BX=sprintf("%x",bg2B);
			bg1RX=sprintf("%x",bg1R); bg1GX=sprintf("%x",bg1G); bg1BX=sprintf("%x",bg1B);
			if(length(fg3RX)==1){fg3RX="0"fg3RX}; if(length(fg3GX)==1){fg3GX="0"fg3GX}
			if(length(fg3BX)==1){fg3BX="0"fg3BX}; if(length(fg2RX)==1){fg2RX="0"fg2RX}
			if(length(fg2GX)==1){fg2GX="0"fg2GX}; if(length(fg2BX)==1){fg2BX="0"fg2BX}
			if(length(fg1RX)==1){fg1RX="0"fg1RX}; if(length(fg1GX)==1){fg1GX="0"fg1GX}
			if(length(fg1BX)==1){fg1BX="0"fg1BX}; if(length(bg1RX)==1){bg1RX="0"bg1RX}
			if(length(bg1GX)==1){bg1GX="0"bg1GX}; if(length(bg1BX)==1){bg1BX="0"bg1BX}
			if(length(bg2RX)==1){bg2RX="0"bg2RX}; if(length(bg2GX)==1){bg2GX="0"bg2GX}
			if(length(bg2BX)==1){bg2BX="0"bg2BX}; if(length(bg3RX)==1){bg3RX="0"bg3RX}
			if(length(bg3GX)==1){bg3GX="0"bg3GX}; if(length(bg3BX)==1){bg3BX="0"bg3BX}

			print "fg3 #" fg3RX fg3GX fg3BX ;
			print "fg2 #" fg2RX fg2GX fg2BX ;
			print "fg1 #" fg1RX fg1GX fg1BX ;
			mixer("acf",acc,fg0,50,50)
			mixer("acb",acc,bg0,50,50)
			print "bg1 #" bg1RX bg1GX bg1BX ;
			print "bg2 #" bg2RX bg2GX bg2BX ;
			print "bg3 #" bg3RX bg3GX bg3BX ;

			mixer("ac88f",acc,fg0,12,88)
			mixer("ac75f",acc,fg0,25,75)
			mixer("ac63f",acc,fg0,37,63)
			mixer("ac50f",acc,fg0,50,50)
			mixer("ac37f",acc,fg0,63,37)
			mixer("ac25f",acc,fg0,75,25)
			mixer("ac12f",acc,fg0,88,12)

			mixer("ac12b",acc,bg0,88,12)
			mixer("ac25b",acc,bg0,75,25)
			mixer("ac37b",acc,bg0,63,37)
			mixer("ac50b",acc,bg0,50,50)
			mixer("ac63b",acc,bg0,37,63)
			mixer("ac75b",acc,bg0,25,75)
			mixer("ac88b",acc,bg0,12,88)

		}' >> $ALL
}

hexrgbraw () {
	eval $(echo $1 | awk -F "" -v NME="$2" '{
			R=$2$3;G=$4$5;B=$6$7;
			print NME "R=" strtonum( "0x" R ) "";
			print NME "G=" strtonum( "0x" G ) "";
			print NME "B=" strtonum( "0x" B ) "";
			}')
}

parse-vars () {
	REPLACE=$(awk '!/\$/ {
			key=$1;$1="";gsub(/^[ \t]+/, "", $0);val=$0;
			print ";s/$" key "/" val "/g";
		}' $ALL | tr -d "\n")
	sed -i "${REPLACE:1}" $ALL
}

create-regex () {
	regex="$(awk '{
			key=$1; $1=""; gsub(/^[ \t]+/, "", $0);
			print ";s/\\%\\%" key "\\%\\%/" $0 "/g";
			if ($0 ~ /#/) { sub(/#/, "", $0); print ";s/@@" key "@@/" $0 "/g"; }
		}' $ALL | tr -d "\n")"
	regex="${regex:1}"
	echo "$regex" > $RGX
}

create-rofi-list () {
	bg0=$(sed '/^bg0 /!d;s/[^ ]* *//'       $ALL)
	fg0=$(sed '/^fg0 /!d;s/[^ ]* *//'       $ALL)
	acc=$(sed '/^acc /!d;s/[^ ]* *//'       $ALL)
	wpr=$(sed '/^wallpaper /!d;s/[^ ]* *//' $ALL)
	CLST1=$TDR/.colorlist1 CLST2=$TDR/.colorlist2 VLST1=$TDR/.varlist
	[[ -n $wpr ]] || wpr=$acc
	echo "				<b><big>$(cat $ALL | sed '/^name/!d;s/[^ ]* *//')</big></b>" > $ALR
	echo "wallpaper $wpr" > $VLST1
	cat $ALL | sed "/^wallpaper/d;/^name/d;/#/d;/,/d" >> $VLST1
	IFS=$'\n'
	awk -v bg0="$bg0" -v fg0="$fg0" ' /#/ && /^bg|^fg|^ac/ {
		var=$1; $1=""; gsub(/^[ \t]+/, "", $0); val=$0;
		print "<span background=\"" val "\">   </span><span foreground=\"" fg0 "\" background=\"" bg0 "\"> " var " " val " </span>";}' $ALL > $CLST1
	awk -v bg0="$bg0" -v fg0="$fg0" ' /#/ && !/^bg|^fg|^ac/ {
		var=$1; $1=""; gsub(/^[ \t]+/, "", $0); val=$0;
		print "<span background=\"" val "\">   </span><span foreground=\"" fg0 "\" background=\"" bg0 "\"> " var " " val " </span>";}' $ALL > $CLST2
	paste $CLST1 $CLST2 $VLST1 >> $ALR
	rm $CLST1 $CLST2 $VLST1
}

updatelist () {
	cd $TDR
	thms=$(ls)
	rm $LST
	for i in $thms; do
		eval $(awk '
			$1~/^fg0$/ { fg0=$2; }; $1~/^bg0$/ { bg0=$2; }; $1~/^acc$/ { acc=$2; };
			fg0~/\$/ {gsub(/^\$/, "", fg0)};
			bg0~/\$/ {gsub(/^\$/, "", bg0)};
			acc~/\$/ {gsub(/^\$/, "", acc)};
			$1~"^"fg0"$" {fg0=$2}; $1~"^"bg0"$" {bg0=$2}; $1~"^"acc"$" {acc=$2};
			END { print "bg0=" bg0 " fg0=" fg0 " acc=" acc }
			' $i)
		[[ ! $fg0 =~ "#" ]] && fg0=$(sed "/^"${fg0/\$/}\ "/!d;s/[^ ]* *//" $DEF)
		[[ ! $acc =~ "#" ]] && acc=$(sed "/^"${acc/\$/}\ "/!d;s/[^ ]* *//" $DEF)
		[[ ! $bg0 =~ "#" ]] && bg0=$(sed "/^"${bg0/\$/}\ "/!d;s/[^ ]* *//" $DEF)
		echo "<span background=\"$acc\">   </span>\
<span foreground=\"$fg0\" background=\"$bg0\"> $i </span>" >> $LST
	done
}

list () {
	[[ -z $1 ]] && exit
	case $1 in
		vars) awk '{key=$1;$1="";gsub(/^[ \t]+/, "", $0);printf "%-19s%s\n", "%%" key "%%", $0;}' $ALL ;;
		vars-rofi) cat $ALR | i3menu -w 800 ;;
		themes)    ls ${TDR} ;;
	esac
}

gui-change () {
	THM=$(cat $LST | i3menu -p "Choose theme ")
	THM=${THM% *}
	THM=${THM##* }
	notify-send "Chosen theme is $THM" -i "${SCR_DIR}pic/theme.png"
	cd ${TDR}
	[[ ! -f ${THM} ]] && notify-send "Theme don't exist"
	[[ -z ${THM} ]]   && notify-send "No theme chosen" || {
		notify-send "Theme exists" && cat ${THM} > ${CUR}
		}
}

getvar () { [[ -n $1 ]] && cat $ALL | sed "/^$1/!d;s/[^ ]* *//" ; }

newtheme () {
	NTHM="${TDR}/${1}"
	echo "! vim:ft=perl" > $NTHM
	echo "Enter accent colour..."     && read ACC && echo "acc    $ACC" >> $NTHM
	echo "Enter background colour..." && read BG0 && echo "bg0    $BG0" >> $NTHM
	echo "Enter foreground colour..." && read FG0 && echo "fg0    $FG0" >> $NTHM
	echo "Theme ${NTHM##*/} created"
}

apply-single () {
	regex=$(cat $RGX)
	DIR="$1"
	cd $DIR
	IFS=$'\n'
	[[ -f _pre-apply ]] && bash _pre-apply &>/dev/null &
	TMPS=$(ls | awk '/template_/')
	for t in ${TMPS}; do
		cat ${t} | sed -e "${regex}" > ${t/template_/}
	done
	[[ -f _post-apply ]] && bash _post-apply &>/dev/null &
	cd
}

apply () { eval "$(awk '!/#/{print "themer -a " $0}' $DIRS)" ; exit ; }

colmix-parse () {
	CMRX="$(awk -i <(awklib) ' $2 ~ /^colmix/ {
			key=$1;$1="";$2="";gsub(/^[ \t]+/, "", $0);mix=$0;
			ONE=substr($0,4,length($0)-14);TWO=substr($0,15,length($0)-1);
			RT1=substr($0,1,length($0)-19);RT2=substr($0,12,length($0)-19);
			colmixparse(key,ONE,TWO,RT1,RT2);
		}' $ALL | tr -d "\n")"
	sed -i "${CMRX:1}" $ALL
}

create-rgb () {
	awk -i <(awklib) '$2 ~ /#/ {
			key=$1;$1="";gsub(/^[ \t]+/, "", $0);
			hextorgb($0,key);
		}' $ALL >> $ALL
}

change-current () {
	[[ -n $1 ]] && cat ${TDR}/${1} > $CUR || gui-change
	[[ -n $DARK ]] && sed -i 's/fg0/bgint/g;s/bg0/fg0/g;s/bgint/bg0/g' $CUR
	cat $CUR | sed '/^\!/d' > $ALL
	awk ' NR==FNR { a[$1]=$1; b[$1]=$0; next; }
		$1!=a[$1] { print $0; }' $ALL $DEF | sed '/^!/d' >> $ALL
	parse-vars
	colmix-parse
	parse-vars
	variations
	parse-vars
	create-rgb
	create-regex
	create-rofi-list
	awk '{ key=$1;$1="";gsub(/^[ \t]+/, "", $0); printf "%-19s%s\n", key, $0;
		}' $ALL > ${TDR}/.tmp && mv ${TDR}/.tmp $ALL
}

delete () { mv ${TDR}/${1} ${TDR}/.unused/${1} ; exit ; }

timechange () {
	AM=${1%:*}
	PM=${1#*:}
	[[ $TIME -ge $PM ]] && DARK=1
	[[ $TIME -lt $AM ]] && DARK=1
}

while true; do
	case $1 in
		--updatelist   | -u ) updatelist              ; shift ;;
		--getvar       | -v ) getvar "${2:-}"         ; shift ;;
		--new          | -n ) newtheme "${2:-}"       ; shift ;;
		--list         | -l ) list "${2:-}"           ; shift ;;
		--change       | -c ) change-current "${2:-}" ; shift ;;
		--apply-single | -a ) apply-single "${2:-}"   ; shift ;;
		--apply-all    | -A ) apply                   ; shift ;;
		--delete       | -d ) delete "${2:-}"         ; shift ;;
		--dark         | -D ) DARK=1                          ;;
		--auto-dark    | -t ) timechange "${2:-}"     ; shift ;;
		--help         | -h ) help                            ;;
		-- ) shift ; break ;;
		*  ) break         ;;
	esac
	shift
done
